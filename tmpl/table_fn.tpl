// Code generated by pgxgen. DO NOT EDIT.
package {{.PackageName}}

import (
	"strconv"
	"strings"

    pgx "github.com/jackc/pgx"
    pgtype "github.com/jackc/pgx/pgtype"
    uuid "github.com/satori/go.uuid"
    store "{{.ImportPath}}/store"
    {{.ModelPackageName}} "{{.ImportPath}}/{{.ModelPackageName}}"
)

//
const (
    {{.Table.ExportedName}}Table = "{{.Table.Name}}"
{{range .Table.Columns -}}
    {{$.Table.ExportedName}}Field{{.ExportedName}} = "{{.Name}}"
{{end -}}
)

// {{.Table.ExportedName}}Fields is a slice of all field names for table '{{.Table.Name}}.'
var {{.Table.ExportedName}}Fields = []string{
{{- range .Table.Columns}}
    "{{.Name}}",
{{- end}}
}

// {{.Table.ExportedName}}FieldsStr is a comma separated string of all field names for table '{{.Table.Name}}.'
const {{.Table.ExportedName}}FieldsStr = "{{range $k, $e := .Table.Columns}}{{if $k}}, {{end}}{{.Name}}{{end}}"

// Scan{{.Table.ExportedName}}s returns a single row containing all fields of '{{.Table.Name}}.' Reading of columns
// from result set is positional, and in the following order:
{{- range .Table.Columns}}
//      {{.Name}}
{{- end}}
func Scan{{.Table.ExportedName}}(row *pgx.Row) (*{{.ModelPackageName}}.{{.Table.ExportedName}}, error) {
	m := &{{.ModelPackageName}}.{{.Table.ExportedName}}{}
	err := row.Scan(
		{{- range .Table.Columns}}
            &m.{{.ExportedName}},
        {{- end}}
	)
	return m, err
}

// Scan{{pluralize .Table.ExportedName}} returns one or more rows containing all fields of '{{.Table.Name}}.' Reading of columns
// from result set is positional, and in the following order:
{{- range .Table.Columns}}
//      {{.Name}}
{{- end}}
func Scan{{pluralize .Table.ExportedName}}(rows *pgx.Rows) ([]*{{.ModelPackageName}}.{{.Table.ExportedName}}, error) {
	var r []*{{.ModelPackageName}}.{{.Table.ExportedName}}
	for rows.Next() {
		m := &{{.ModelPackageName}}.{{.Table.ExportedName}}{}
		err := rows.Scan(
		{{- range .Table.Columns}}
            &m.{{.ExportedName}},
        {{- end}}
		)
		if err != nil {
		    continue
		}
		r = append(r, m)
	}
	return r, nil
}

// Create{{.Table.ExportedName}} create a single row in '{{.Table.Name}}' and return it.
func Create{{.Table.ExportedName}}(conn store.PostgresConnection, m *{{.ModelPackageName}}.{{.Table.ExportedName}}) (*{{.ModelPackageName}}.{{.Table.ExportedName}}, error) {
	var f []string
	var v []string
	var c int
	var a []interface{}

    {{range .Table.Columns}}
        if m.{{.ExportedName}}.Status != pgtype.Undefined {
            c++
            f = append(f, "{{.Name}}")
            v = append(v, "$"+strconv.Itoa(c))
            a = append(a, &m.{{.ExportedName}})
        }
    {{- end}}

	q := "INSERT INTO {{.Table.Schema}}.{{.Table.Name}} (" + strings.Join(f, ", ") + ") VALUES(" + strings.Join(v, ", ") + ") RETURNING " + {{.Table.ExportedName}}FieldsStr + ";"

	row := conn.QueryRow(q, a...)
	r, err := Scan{{.Table.ExportedName}}(row)
	return r, ToStoreErr("Create{{.Table.ExportedName}}", err)
}

// Update{{.Table.ExportedName}} updates a row in '{{.Table.Name}}.'
func Update{{.Table.ExportedName}}(conn store.PostgresConnection, {{range $k, $pk := .Table.PrimaryKeys}}{{if $k}}, {{end}}{{.GoVar}} {{.QualifiedGoType $.ModelPackageName}}{{end}}, m *{{.ModelPackageName}}.{{.Table.ExportedName}}) (*{{.ModelPackageName}}.{{.Table.ExportedName}}, error) {
	var f []string
	var pk []string
	var c int
	var a []interface{}

    {{range .Table.PrimaryKeys}}
        { // Primary Key: {{.Name}}
        		c++
        		pk = append(pk, "{{.Name}} = $"+strconv.Itoa(c))
        		a = append(a, &{{.GoVarTemplate}})
        }
    {{- end}}

    {{range .Table.Columns}}
        {{- if not .IsPK}}
        if m.{{.ExportedName}}.Status != pgtype.Undefined {
            c++
            f = append(f, "{{.Name}} = $"+strconv.Itoa(c))
            a = append(a, &m.{{.ExportedName}})
        }
        {{- end}}
    {{- end}}


	q := "UPDATE {{.Table.Schema}}.{{.Table.Name}} SET " + strings.Join(f, ", ") + " WHERE " + strings.Join(pk, " AND ") + " RETURNING " + {{.Table.ExportedName}}FieldsStr + ";"
	row := conn.QueryRow(q, a...)
	r, err := Scan{{.Table.ExportedName}}(row)
	return r, ToStoreErr("Update{{.Table.ExportedName}}", err)
}

// Delete{{.Table.ExportedName}} returns a row from '{{.Table.Name}}.' identified by primary key.
func Delete{{.Table.ExportedName}}(conn store.PostgresConnection, {{range $k, $pk := .Table.PrimaryKeys}}{{if $k}}, {{end}}{{.GoVar}} {{.QualifiedGoType $.ModelPackageName}}{{end}}) error {
	q := "DELETE FROM {{.Table.Schema}}.{{.Table.Name}} WHERE {{range $k, $pk := .Table.PrimaryKeys}}{{if $k}} AND {{end}}{{.Name}} = ${{inc $k}}{{end}};"
	_, err := conn.Exec(q, {{range $k, $pk := .Table.PrimaryKeys}}{{if $k}}, {{end}}{{.GoVarTemplate}}{{end}})
    return ToStoreErr("Delete{{.Table.ExportedName}}", err)
}
