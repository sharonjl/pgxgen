// Code generated by pgxgen. DO NOT EDIT.
package builder

import (
	"bytes"
	"fmt"
	"log"
	"reflect"
	"strconv"
	"strings"

	"github.com/sharonjl/pgxgen/gen/model"
)

// Table map
var tableMap = map[reflect.Type]Tabler{
	reflect.TypeOf(&model.StoryView{}):      StoryView,
	reflect.TypeOf(&model.ReactionView{}):   ReactionView,
	reflect.TypeOf(&model.StoryBit{}):       StoryBit,
	reflect.TypeOf(&model.Login{}):          Login,
	reflect.TypeOf(&model.Device{}):         Device,
	reflect.TypeOf(&model.Profile{}):        Profile,
	reflect.TypeOf(&model.Subscription{}):   Subscription,
	reflect.TypeOf(&model.ReactionBit{}):    ReactionBit,
	reflect.TypeOf(&model.CounterProfile{}): CounterProfile,
	reflect.TypeOf(&model.CounterStory{}):   CounterStory,
	reflect.TypeOf(&model.StoryLike{}):      StoryLike,
	reflect.TypeOf(&model.Story{}):          Story,
}

// ---------------------------------------------------------------------------------------------------------------------

type Fn func() ([]*InputArg, *SqlBuilder, *ReturnType)

type InputArg struct {
	name   string
	typeOf reflect.Type
}

func NewArg(name string, typeof reflect.Type) *InputArg {
	return &InputArg{name: name, typeOf: typeof}
}

type ReturnType struct {
	typeOf reflect.Type
}

func NewReturnType(typeof reflect.Type) *ReturnType {
	return &ReturnType{typeOf: typeof}
}

type SqlBuilder struct {
	stmt []interface{}
}

func SQL(w ...interface{}) *SqlBuilder {
	return &SqlBuilder{stmt: w}
}

// ---------------------------------------------------------------------------------------------------------------------

type table struct {
	name   string
	alias  string
	gotype string
}

func (t *table) WithAlias(s string) *table {
	return &table{name: t.name, alias: s, gotype: t.gotype}
}

type Tabler interface {
	GetTable() *table
	GetColumns() []*column
}

type Columner interface {
	GetColumn() *column
}

type column struct {
	table   string
	name    string
	expName string
	alias   string
	gotype  string
	pgtype  string
	pgxtype string
}

func (c *column) WithAlias(s string) *column {
	return &column{
		alias:   s,
		table:   c.table,
		name:    c.name,
		expName: c.expName,
		gotype:  c.gotype,
		pgtype:  c.pgtype,
		pgxtype: c.pgxtype,
	}
}

type fieldList struct {
	fields []*column
	v      *InputArg
	tmpl   string
	delim  string
}

func DefinedFields(v *InputArg, tmpl string, delim string, fields ...*column) *fieldList {
	fl := &fieldList{v: v, tmpl: tmpl, delim: delim, fields: fields}
	if fl.fields == nil || len(fl.fields) == 0 {
		fl.fields = tableMap[v.typeOf].GetColumns()
	}
	return &fieldList{v: v, tmpl: tmpl, delim: delim, fields: fields}
}

func Print(fn Fn) {
	args, sql, ret := fn()

	funcArgs := []string{}
	for _, a := range args {
		s := a.name + " "
		_ = a.typeOf.Kind() == reflect.Ptr
		_ = a.typeOf.Kind() == reflect.Slice
		s = s + a.typeOf.String()
		funcArgs = append(funcArgs, s)
	}

	g := GenIO{Buffer: &bytes.Buffer{}}
	if len(funcArgs) == 0 {
		g.P(`func Insert(db pgx.Conn) `, ret.typeOf.String(), ` {`).In()
	} else {
		g.P(`func Insert(db pgx.Conn, `, strings.Join(funcArgs, ", "), `) `, ret.typeOf.String(), ` {`).In()
	}

	var cs []string
	printString := func() {
		if len(cs) == 0 {
			return
		}
		g.Line()
		g.P(`___q = ___q + "`, strings.Join(cs, ""), `"`)
		cs = []string{}
	}

	g.P(`___c := 0`)
	g.P(`___a := []interface{}`)
	g.P(`___q := ""`)
	for _, stmt := range sql.stmt {
		switch v := stmt.(type) {
		case string:
			cs = append(cs, v)
		case Tabler:
			cs = append(cs, v.GetTable().name)
		case *column:
			cs = append(cs, v.table+"."+v.name)
		case *InputArg:
			printString()
			g.Line()
			g.P(`// Input: `, v.name)
			g.P(`___c++`)
			g.P(`___a = append(___a, `, v.name, `)`)
			g.P(`___q = ___q + "$" + strconv.Itoa(___c)`)
		case *fieldList:
			for _, field := range tableMap[v.v.typeOf].GetColumns() {
				g.P(`if `, v.v.name, `.`, field.expName, ` != pgtype.Undefined {`).In()
				g.P(`___c++`)
				g.P(`___a = append(___a, `, v.v.name, `.`, field.expName, `)`)
				stmpl := strings.Replace(v.tmpl, "{NAME}", field.name, -1)
				stmpl = strings.Replace(stmpl, "{VALUE}", `"$" + strconv.Itoa(___c)`, -1)
				g.P(`___q = ___q + `, stmpl)
				g.Out()
				g.P(`}`)
			}
		default:
			printString()
		}
	}
	printString()
	g.Out()
	g.P(`}`)
	log.Print(g.String())
}

func writeArg(c *int, aa *[]interface{}, v interface{}) string {
	*c++
	*aa = append(*aa, v)
	return strconv.Itoa(*c)
}

// ---------------------------------------------------------------------------------------------------------------------

type GenIO struct {
	*bytes.Buffer

	indent  string
	pkgName string
}

func (g *GenIO) P(str ...interface{}) *GenIO {
	g.WriteString(g.indent)
	for _, v := range str {
		switch s := v.(type) {
		case string:
			g.WriteString(s)
		case *string:
			g.WriteString(*s)
		case bool:
			fmt.Fprintf(g, "%t", s)
		case *bool:
			fmt.Fprintf(g, "%t", *s)
		case int:
			fmt.Fprintf(g, "%d", s)
		case int32:
			fmt.Fprintf(g, "%d", s)
		case int64:
			fmt.Fprintf(g, "%d", s)
		case *int32:
			fmt.Fprintf(g, "%d", *s)
		case *int64:
			fmt.Fprintf(g, "%d", *s)
		case float64:
			fmt.Fprintf(g, "%g", s)
		case *float64:
			fmt.Fprintf(g, "%g", *s)
		default:
			panic(fmt.Sprintf("unknown type in printer: %T", v))
		}
	}
	g.WriteByte('\n')
	return g
}

func (g *GenIO) Line() *GenIO {
	g.WriteByte('\n')
	return g
}

func (g *GenIO) In() *GenIO {
	g.indent += "\t"
	return g
}

func (g *GenIO) Out() *GenIO {
	if len(g.indent) > 0 {
		g.indent = g.indent[1:]
	}
	return g
}

// ---------------------------------------------------------------------------------------------------------------------
