// Code generated by pgxgen. DO NOT EDIT.
package {{.PackageName}}

import (
	"strconv"
	"strings"

    pgx "github.com/jackc/pgx"
    pgtype "github.com/jackc/pgx/pgtype"
    uuid "github.com/satori/go.uuid"
    store "{{.ImportPath}}/store"
    {{.ModelPackageName}} "{{.ImportPath}}/{{.ModelPackageName}}"
)

{{range .Queries}}
func (st *PGStore) {{.Name}}({{range $k, $fd := .Filter}}{{if $k}}, {{end}}{{.Column.GoVar}} {{if eq .Op "in"}}[]{{end}}{{.Column.QualifiedPgxType  $.ModelPackageName}}{{end}}) (*{{$.ModelPackageName}}.{{.Table.ExportedName}}, error) {
     d, err := st.generatedLoaders.{{.Name}}.Load(context.Background(), store.Key{{.Name}}{ {{range $k, $fd := .Filter}}{{if $k}}, {{end}}{{.Column.ExportedName}}: {{.Column.GoVar}}{{end}} })()
     if err != nil {
        return nil, err
     }
     return d.(*{{$.ModelPackageName}}.{{.Table.ExportedName}}), nil
}

{{if .ReturnOne}}
func batchFunc{{.Name}}(conn store.PostgresConnection) dataloader.BatchFunc {
    return func(_ context.Context, keys dataloader.Keys) []*dataloader.Result {
            var results []*dataloader.Result

            var args []interface{}
            var pars []string
            var i int
            rmap := make(map[string]*{{$.ModelPackageName}}.{{.Table.ExportedName}})

            for _, k := range keys {
                rmap[k.String()] = nil

                key, ok := k.(store.Key{{.Name}})
                if !ok {
                    continue
                }

                var p []string
                {{range .Filter -}}
                {
                    i++
                    args = append(args, &key.{{.Column.ExportedName}})
                    p = append(p, "$" + strconv.Itoa(i))
                }
                {{end}}
                pars = append(pars, "(" + strings.Join(p, ", ") + ")")
            }

            q := "SELECT " + {{.Table.ExportedName}}FieldsStr + " FROM {{.Table.Schema}}.{{.Table.Name}} WHERE ({{range $k, $fd := .Filter}}{{if $k}}, {{end}}{{.Column.Name}}{{end}}) IN (" + strings.Join(pars, ",") + ");"

            rows, err := conn.Query(q, args...)
            defer rows.Close()
            rr, err := Scan{{pluralize .Table.ExportedName}}(rows)
            if err != nil {
                // Log error
            }
            for _, r := range rr {
                key := store.MkKeyStr{{.Name}}({{range $k, $fd := .Filter}}{{if $k}}, {{end}}r.{{.Column.ExportedName}}{{end}})
                rmap[key] = r
            }
            for _, key := range keys {
                var err error
                d, ok := rmap[key.String()]
                if !ok {
                    err = pgx.ErrNoRows
                }
                results = append(results, &dataloader.Result{Data: d, Error: ToStoreErr("{{.Name}}BatchFunc", err)})
            }
            return results
        }
}
{{end}}

{{if .ReturnMany}}
func batchFunc{{.Name}}(conn store.PostgresConnection) dataloader.BatchFunc {
    return func(_ context.Context, keys dataloader.Keys) []*dataloader.Result {
            var results []*dataloader.Result

            var args []interface{}
            var pars []string
            var qry  []string
            var i int

            rmap := make(map[string]*{{$.ModelPackageName}}.{{.Table.ExportedName}})
            for _, k := range keys {
                rmap[k.String()] = nil

                key, ok := k.(store.Key{{.Name}})
                if !ok {
                    continue
                }

                {{range $k, $fd := .Filter -}}
                    {{if eq .Op "in" -}}
                    {
                        // Field: {{.Column.Name}}
                        var p []string
                        for _, m := range key.{{.Column.ExportedName}} {
                            i++
                            args = append(args, &m)
                            p = append(p, "$" + strconv.Itoa(i))
                        }
                        if len(p) == 1 {
                            pars = append(pars, "{{.Column.Name}} = " + p[0])
                        }
                        if len(p) > 1 {
                            pars = append(pars, "{{.Column.Name}} IN (" + strings.Join(p, ", ") + ")")
                        }
                     }
                    {{end -}}
                    {{if ne .Op "in" -}}
                    {
                        // Field: {{.Column.Name}}
                        i++
                        args = append(args, &key.{{.Column.ExportedName}})
                        pars = append(pars, "{{.Column.Name}} {{.SQLOp}} " + "$" + strconv.Itoa(i))
                    }
                    {{end -}}
                {{end -}}

                q := "(SELECT '" + key.String() + "' as __key_id, json_agg(row_to_json(t))::JSONB FROM (SELECT {{range $k, $c := .Table.Columns}}{{if $k}}, {{end}}{{.Name}}{{end}} FROM {{.Table.Name}} WHERE " + strings.Join(pars, " AND ") + "ORDER BY {{range $k, $s := .Sort}}{{if $k}}, {{end}}{{.Column.Name}} {{.}}{{end}}) t)"
                qry = append(qry, q)
            }

            q := strings.Join(qry, " UNION ALL ") + ";"

            rows, err := conn.Query(q, args...)
            defer rows.Close()
            var rr []*{{$.ModelPackageName}}.{{.Table.ExportedName}}
            for rows.Next() && err != nil {
                var key string
                var json pgtype.JSONB
                var r {{$.ModelPackageName}}.{{.Table.ExportedName}}
                err := rows.Scan(&key, &json)
                if err != nil {
                    continue
                }
                err = json.Scan(&r)
                if err != nil {
                    continue
                }
                rr = append(rr, &r)
                rmap[key] = &r
            }
            if err != nil {
                // TODO: Log error
            }
            for _, key := range keys {
                var err error
                d, ok := rmap[key.String()]
                if !ok {
                    err = pgx.ErrNoRows
                }
                results = append(results, &dataloader.Result{Data: d, Error: ToStoreErr("batchFunc{{.Name}}", err)})
            }
            return results
        }
}
{{end}}
{{end}}
